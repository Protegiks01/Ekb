# Audit Report

## Title
MEVCapture Intra-Block Fee Timing Vulnerability Allows LP Fee Theft

## Summary
The MEVCapture extension contains a critical timing vulnerability where fees generated by swaps in Block N are added to `savedBalances` but not accumulated to the pool's `feesPerLiquidity` until Block N+1. Attackers can add liquidity in Block N after swaps generate fees, setting their `feesPerLiquidityInsideLast` baseline before fee accumulation occurs, thereby receiving a disproportionate share of fees they did not earn.

## Impact
**Severity**: High

This vulnerability enables direct theft of LP fees through timing manipulation. An attacker adding liquidity equal to existing pool liquidity steals ~50% of MEV fees from that block. With 9x existing liquidity, they capture ~90% of fees. This attack is repeatable every block with swap activity, systematically draining legitimate LP earnings. The vulnerability affects all MEVCapture-enabled pools and violates the fundamental principle that positions should only earn fees during periods they actively provide liquidity.

## Finding Description

**Location:** `src/extensions/MEVCapture.sol` - `handleForwardData()` function (lines 177-260) and `accumulatePoolFees()` function (lines 105-125)

**Intended Logic:** 
Per the code comment "Prevents new liquidity from collecting on fees" [1](#0-0) , MEVCapture intends to ensure positions only earn fees for swaps occurring while they actively provide liquidity. Fees should be accumulated atomically when generated.

**Actual Logic:**
When `handleForwardData()` processes the first swap in a block, it accumulates old fees and immediately updates `lastUpdateTime` to the current block timestamp [2](#0-1) . Subsequently, when the swap generates new MEV fees, these are added to `savedBalances` [3](#0-2)  but NOT accumulated to `feesPerLiquidity` in the same transaction. This creates a one-block delay where fees exist in `savedBalances` but haven't been distributed to existing positions.

**Exploitation Path:**

1. **Block N, T1 - Swap generates fees:**
   - User calls swap through `MEVCapture.forward()`
   - `handleForwardData()` checks `if (lastUpdateTime != currentTime)` - TRUE for first swap [4](#0-3) 
   - Accumulates old fees from previous block [5](#0-4) 
   - Updates `lastUpdateTime = uint32(block.timestamp)` (Block N) [2](#0-1) 
   - Swap executes and generates new MEV fees based on tick movement [6](#0-5) 
   - New fees added to `savedBalances` via `updateSavedBalances()` [7](#0-6) 
   - **Critical state:** `lastUpdateTime = Block N`, new fees in `savedBalances`, NOT in `feesPerLiquidity`

2. **Block N, T2 - Attacker adds liquidity:**
   - Attacker calls `Core.updatePosition()` to add liquidity
   - `beforeUpdatePosition` hook invoked [8](#0-7) 
   - MEVCapture's hook calls `accumulatePoolFees()` [9](#0-8) 
   - Check `state.lastUpdateTime() != uint32(block.timestamp)` evaluates FALSE (both equal Block N) [10](#0-9) 
   - Function returns without calling `locked_6416899205()`, no fees accumulated
   - `updatePosition()` calculates `feesPerLiquidityInside` using current pool state WITHOUT new MEV fees [11](#0-10) 
   - Attacker's position sets `feesPerLiquidityInsideLast` to this pre-accumulation value [12](#0-11) 

3. **Block N+1 - Fee accumulation:**
   - Any transaction triggers `accumulatePoolFees()`
   - Now `lastUpdateTime (Block N) != block.timestamp (Block N+1)` evaluates TRUE
   - Calls `locked_6416899205()` which loads fees from `savedBalances` [13](#0-12) 
   - `accumulateAsFees()` increases pool's `feesPerLiquidity` by distributing fees across ALL current liquidity [14](#0-13) 
   - Attacker's position now benefits from increased `feesPerLiquidity`

4. **Fee collection:**
   - Position fee calculation: `fees = (feesPerLiquidityInside - feesPerLiquidityInsideLast) * liquidity` [15](#0-14) 
   - Attacker receives large share of MEV fees generated BEFORE they provided liquidity
   - Legitimate LPs who were active during Block N swap receive diluted fees

**Security Property Broken:**
Violates the invariant that positions should only earn fees for periods they actively provide liquidity. The code comment explicitly states the intent to "prevent new liquidity from collecting on fees" [1](#0-0) , demonstrating this is unintended behavior.

## Impact Explanation

**Affected Assets:** All MEVCapture-enabled pools and their liquidity provider positions.

**Damage Severity:**
- Attacker adding liquidity equal to existing pool liquidity steals ~50% of MEV fees from that block
- Attacker adding 9x existing liquidity captures ~90% of fees
- Attack is repeatable every block with swap activity
- Legitimate LPs systematically lose significant fee earnings
- High-volume pools with substantial MEV fees suffer greatest impact

**User Impact:** All legitimate liquidity providers in MEVCapture pools receive diluted fee earnings. Victims cannot prevent the attack as it exploits the protocol's fee accumulation timing mechanism.

**Trigger Conditions:** Any user can execute this attack with capital (including flash loans) whenever swaps generate MEV fees.

## Likelihood Explanation

**Attacker Profile:** Any user with capital access. No special permissions, privileges, or insider knowledge required. MEV searchers and bots will automate this attack.

**Preconditions:**
1. Pool uses MEVCapture extension (intended for all pools capturing MEV)
2. Swaps generate MEV fees through tick movement (common in volatile markets)
3. Pool has liquidity to make attack profitable

**Execution Complexity:** Simple single-block attack pattern:
- Monitor mempool for large swaps through MEVCapture
- Submit transaction adding liquidity immediately after observing swap
- Collect fees in next block
- Remove liquidity and repeat

Attackers can use flash loans to amplify impact without permanent capital commitment.

**Economic Cost:** Only gas fees for position management. No capital lockup required with flash loans.

**Frequency:** Exploitable every block with swap activity. Scalable across all MEVCapture pools simultaneously.

**Overall Likelihood:** HIGH - Trivially automatable, economically rational, repeatable attack with clear profit mechanism.

## Recommendation

**Primary Fix:**
The vulnerability stems from updating `lastUpdateTime` in `handleForwardData()` BEFORE new fees are accumulated. Modify `handleForwardData()` to accumulate fees IMMEDIATELY after generating them in the same transaction:

```solidity
// In src/extensions/MEVCapture.sol, function handleForwardData(), after line 252:
// Add immediate fee accumulation before updating savedBalances:

if (saveDelta0 != 0 || saveDelta1 != 0) {
    // Accumulate fees immediately to current liquidity providers
    CORE.accumulateAsFees(poolKey, uint128(uint256(saveDelta0)), uint128(uint256(saveDelta1)));
    // No need to save to savedBalances since already accumulated
}

// Remove or modify line 255 since fees are now accumulated immediately
```

This ensures fees are distributed atomically to the exact set of LPs who were active during the swap, eliminating the timing window for exploitation.

**Alternative Mitigation:**
Track which block fees were generated and prevent positions created in that block from claiming those fees. However, this adds complexity and the immediate accumulation approach is cleaner.

## Notes

The claim's proposed fix targeting `locked_6416899205()` is incorrect and would not resolve the vulnerability. The root cause is in `handleForwardData()`'s sequence of operations: it updates `lastUpdateTime` (line 203-206) before new fees are generated (lines 212-252) and saved (line 255). This temporal ordering creates the exploitation window.

The vulnerability is particularly severe because:
1. It's invisible to victims - LPs see reduced earnings with no indication of theft
2. It's economically rational - profitable for attackers to exploit continuously
3. It's automatable - MEV bots can execute this systematically across all pools
4. It violates the stated design intent per code comments

This is NOT standard concentrated liquidity behavior. In Uniswap v3 and similar protocols, fees are accumulated immediately when generated, preventing this timing attack vector.

### Citations

**File:** src/extensions/MEVCapture.sol (L96-96)
```text
    /// Prevents new liquidity from collecting on fees
```

**File:** src/extensions/MEVCapture.sol (L97-102)
```text
    function beforeUpdatePosition(Locker, PoolKey memory poolKey, PositionId, int128)
        external
        override(BaseExtension, IExtension)
    {
        accumulatePoolFees(poolKey);
    }
```

**File:** src/extensions/MEVCapture.sol (L110-110)
```text
        if (state.lastUpdateTime() != uint32(block.timestamp)) {
```

**File:** src/extensions/MEVCapture.sol (L136-148)
```text
        (int32 tick, uint128 fees0, uint128 fees1) = loadCoreState(poolId, poolKey.token0, poolKey.token1);

        if (fees0 != 0 || fees1 != 0) {
            CORE.accumulateAsFees(poolKey, fees0, fees1);
            unchecked {
                CORE.updateSavedBalances(
                    poolKey.token0,
                    poolKey.token1,
                    PoolId.unwrap(poolId),
                    -int256(uint256(fees0)),
                    -int256(uint256(fees1))
                );
            }
```

**File:** src/extensions/MEVCapture.sol (L191-191)
```text
            if (lastUpdateTime != currentTime) {
```

**File:** src/extensions/MEVCapture.sol (L195-199)
```text
                if (fees0 != 0 || fees1 != 0) {
                    CORE.accumulateAsFees(poolKey, fees0, fees1);
                    // never overflows int256 container
                    saveDelta0 -= int256(uint256(fees0));
                    saveDelta1 -= int256(uint256(fees1));
```

**File:** src/extensions/MEVCapture.sol (L203-206)
```text
                setPoolState({
                    poolId: poolId,
                    state: createMEVCapturePoolState({_lastUpdateTime: currentTime, _tickLast: tickLast})
                });
```

**File:** src/extensions/MEVCapture.sol (L212-252)
```text
            uint256 feeMultiplierX64 =
                (FixedPointMathLib.abs(stateAfter.tick() - tickLast) << 64) / poolKey.config.concentratedTickSpacing();
            uint64 poolFee = poolKey.config.fee();
            uint64 additionalFee = uint64(FixedPointMathLib.min(type(uint64).max, (feeMultiplierX64 * poolFee) >> 64));

            if (additionalFee != 0) {
                if (params.isExactOut()) {
                    // take an additional fee from the calculated input amount equal to the `additionalFee - poolFee`
                    if (balanceUpdate.delta0() > 0) {
                        uint128 inputAmount = uint128(uint256(int256(balanceUpdate.delta0())));
                        // first remove the fee to get the original input amount before we compute the additional fee
                        inputAmount -= computeFee(inputAmount, poolFee);
                        int128 fee = SafeCastLib.toInt128(amountBeforeFee(inputAmount, additionalFee) - inputAmount);

                        saveDelta0 += fee;
                        balanceUpdate = createPoolBalanceUpdate(balanceUpdate.delta0() + fee, balanceUpdate.delta1());
                    } else if (balanceUpdate.delta1() > 0) {
                        uint128 inputAmount = uint128(uint256(int256(balanceUpdate.delta1())));
                        // first remove the fee to get the original input amount before we compute the additional fee
                        inputAmount -= computeFee(inputAmount, poolFee);
                        int128 fee = SafeCastLib.toInt128(amountBeforeFee(inputAmount, additionalFee) - inputAmount);

                        saveDelta1 += fee;
                        balanceUpdate = createPoolBalanceUpdate(balanceUpdate.delta0(), balanceUpdate.delta1() + fee);
                    }
                } else {
                    if (balanceUpdate.delta0() < 0) {
                        uint128 outputAmount = uint128(uint256(-int256(balanceUpdate.delta0())));
                        int128 fee = SafeCastLib.toInt128(computeFee(outputAmount, additionalFee));

                        saveDelta0 += fee;
                        balanceUpdate = createPoolBalanceUpdate(balanceUpdate.delta0() + fee, balanceUpdate.delta1());
                    } else if (balanceUpdate.delta1() < 0) {
                        uint128 outputAmount = uint128(uint256(-int256(balanceUpdate.delta1())));
                        int128 fee = SafeCastLib.toInt128(computeFee(outputAmount, additionalFee));

                        saveDelta1 += fee;
                        balanceUpdate = createPoolBalanceUpdate(balanceUpdate.delta0(), balanceUpdate.delta1() + fee);
                    }
                }
            }
```

**File:** src/extensions/MEVCapture.sol (L254-256)
```text
            if (saveDelta0 != 0 || saveDelta1 != 0) {
                CORE.updateSavedBalances(poolKey.token0, poolKey.token1, PoolId.unwrap(poolId), saveDelta0, saveDelta1);
            }
```

**File:** src/Core.sol (L254-267)
```text
                if (liquidity != 0) {
                    StorageSlot slot0 = CoreStorageLayout.poolFeesPerLiquiditySlot(poolId);

                    if (amount0 != 0) {
                        slot0.store(
                            bytes32(uint256(slot0.load()) + FixedPointMathLib.rawDiv(amount0 << 128, liquidity))
                        );
                    }
                    if (amount1 != 0) {
                        StorageSlot slot1 = slot0.next();
                        slot1.store(
                            bytes32(uint256(slot1.load()) + FixedPointMathLib.rawDiv(amount1 << 128, liquidity))
                        );
                    }
```

**File:** src/Core.sol (L367-368)
```text
        IExtension(poolKey.config.extension())
            .maybeCallBeforeUpdatePosition(locker, poolKey, positionId, liquidityDelta);
```

**File:** src/Core.sol (L403-407)
```text
                if (liquidityNext != 0) {
                    feesPerLiquidityInside = _getPoolFeesPerLiquidityInside(
                        poolId, state.tick(), positionId.tickLower(), positionId.tickUpper()
                    );
                }
```

**File:** src/Core.sol (L436-437)
```text
                position.feesPerLiquidityInsideLast =
                    feesPerLiquidityInside.sub(feesPerLiquidityFromAmounts(fees0, fees1, liquidityNext));
```

**File:** src/types/position.sol (L33-51)
```text
function fees(Position memory position, FeesPerLiquidity memory feesPerLiquidityInside)
    pure
    returns (uint128, uint128)
{
    uint128 liquidity;
    uint256 difference0;
    uint256 difference1;
    assembly ("memory-safe") {
        liquidity := mload(add(position, 0x20))
        // feesPerLiquidityInsideLast is now at offset 0x40 due to extraData field
        let positionFpl := mload(add(position, 0x40))
        difference0 := sub(mload(feesPerLiquidityInside), mload(positionFpl))
        difference1 := sub(mload(add(feesPerLiquidityInside, 0x20)), mload(add(positionFpl, 0x20)))
    }

    return (
        uint128(FixedPointMathLib.fullMulDivN(difference0, liquidity, 128)),
        uint128(FixedPointMathLib.fullMulDivN(difference1, liquidity, 128))
    );
```
