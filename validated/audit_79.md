# Audit Report

## Title
Integer Overflow on Negation of type(int128).min During Position Withdrawal

## Summary
In BasePositions.sol, withdrawal operations directly negate int128 delta values without boundary checks. When Core returns `type(int128).min` (-2^127), the negation `-type(int128).min` overflows in Solidity 0.8.x, causing transaction reverts that permanently lock user funds in positions, violating the protocol's documented withdrawal availability invariant.

## Impact
**Severity**: Medium

Users cannot withdraw liquidity positions when calculated withdrawal amounts reach the exact int128 minimum boundary. While funds remain in the pool and are not stolen, they become permanently inaccessible to position owners through normal withdrawal mechanisms. This directly violates the documented invariant: "All positions should be able to be withdrawn at any time" [1](#0-0) 

## Finding Description

**Location:** `src/base/BasePositions.sol:310-311`, function `handleLockData()`

**Intended Logic:** 
When withdrawing liquidity, the code should convert negative delta values (representing tokens owed to the user) into positive uint128 amounts for token transfers. The comment at line 318 states the cast is safe because "delta0 and delta1 were originally int128" [2](#0-1) 

**Actual Logic:**
The code directly negates int128 values without checking for `type(int128).min`. In Solidity 0.8.x, negating -2^127 attempts to produce 2^127, which exceeds `type(int128).max` (2^127 - 1), causing arithmetic overflow and transaction revert [3](#0-2) 

**Exploitation Path:**
1. **Precondition**: User creates position with liquidity and price parameters such that `liquidityDeltaToAmountDelta` calculates withdrawal amounts of exactly 2^127 for token0 or token1
2. **Delta Calculation**: Core's math functions (`amount0DeltaSorted`/`amount1DeltaSorted`) return uint128 value of 2^127 [4](#0-3) 
3. **Sign Application**: `liquidityDeltaToAmountDelta` applies negative sign, producing `SafeCastLib.toInt128(-2^127)` which equals `type(int128).min` (valid int128) [5](#0-4) 
4. **Negation Overflow**: BasePositions attempts `uint128(-type(int128).min)` which overflows and reverts
5. **Fund Lock**: User cannot withdraw position, funds remain locked

**Security Property Broken:**
The withdrawal availability invariant is violated - positions cannot be withdrawn at all times as documented [1](#0-0) 

**Additional Vulnerable Locations:**
- BasePositions.sol:62 (getPositionFeesAndLiquidity view function) [6](#0-5) 
- Router.sol:116 (swap amount calculation) [7](#0-6) 
- Router.sol:123, 130 (token withdrawals)

**Core Explicitly Produces the Problematic Value:**
Core.sol deliberately clamps swap calculations to `type(int128).min`, confirming this value is intentionally generated by the protocol [8](#0-7) 

## Impact Explanation

**Affected Assets**: User liquidity positions where withdrawal calculations produce token amounts of exactly 2^127 (170141183460469231731687303715884105728)

**Damage Severity**:
- Users cannot withdraw affected positions through standard mechanisms
- Funds remain in pool but are inaccessible to rightful owners
- Permanent lock without theft (Medium severity per Code4rena framework)
- View function `getPositionFeesAndLiquidity` also fails for affected positions

**User Impact**: Any user whose position parameters (liquidity amount, price range, current price) mathematically combine to produce withdrawal amounts at this exact boundary

**Trigger Conditions**: Occurs naturally when attempting to withdraw affected positions - no attack required

## Likelihood Explanation

**Attacker Profile**: Not an attack - this is a logic error affecting legitimate users with specific position parameters

**Preconditions**:
1. Position must exist with liquidity L, tick range [tickLower, tickUpper], and current price such that: `amount0Delta` or `amount1Delta` calculation returns exactly 2^127
2. No special pool state or external conditions required
3. Mathematical boundary must be hit exactly

**Execution Complexity**: Issue manifests automatically during normal withdrawal operations. No special techniques required.

**Economic Cost**: Standard transaction gas only

**Frequency**: Very rare - requires hitting exact mathematical boundary. The delta calculation functions contain no special protections preventing 2^127 from being returned [9](#0-8) 

**Overall Likelihood**: LOW - Extremely rare boundary condition, but mathematically possible

## Recommendation

**Primary Fix - Use Safe Absolute Value Conversion:**

Replace direct negation with `FixedPointMathLib.abs()`, following the pattern already used correctly in TWAMM.sol and MEVCapture.sol: [10](#0-9) [11](#0-10) 

**Alternative Fix - Explicit Boundary Check:**

Add explicit check for `type(int128).min` before negation and revert with descriptive error.

**Apply Fix to All Vulnerable Locations:**
- BasePositions.sol:62, 310-311
- Router.sol:116, 123, 130

## Proof of Concept

The vulnerability is confirmed by Solidity 0.8.x arithmetic semantics: negating `type(int128).min` always overflows because 2^127 exceeds `type(int128).max`. This is demonstrable in any Solidity 0.8.x environment without requiring specific pool parameters.

The mathematical possibility is confirmed by examining the delta calculation functions which allow any uint128 value up to 2^128-1, including 2^127, to be returned and subsequently cast to int128 via sign application.

## Notes

**Key Evidence of Bug:**
1. The developer comment at line 318 is incorrect - it claims casts won't overflow, but negating `type(int128).min` demonstrably overflows [2](#0-1) 

2. The codebase already uses the safe `FixedPointMathLib.abs()` pattern in other locations (TWAMM, MEVCapture), indicating awareness of proper conversion methods, but BasePositions and Router use the unsafe direct negation pattern

3. Core.sol explicitly generates `type(int128).min` values via deliberate clamping in swap logic, confirming this is not a theoretical-only edge case [8](#0-7) 

**Systemic Issue:** This pattern appears in multiple critical locations across the codebase, suggesting a systematic oversight rather than isolated incident.

### Citations

**File:** README.md (L202-202)
```markdown
All positions should be able to be withdrawn at any time (except for positions using third-party extensions; the extensions in the repository should never block withdrawal within the block gas limit).
```

**File:** src/base/BasePositions.sol (L62-62)
```text
        (principal0, principal1) = (uint128(-delta0), uint128(-delta1));
```

**File:** src/base/BasePositions.sol (L310-311)
```text
                uint128 withdrawnAmount0 = uint128(-balanceUpdate.delta0());
                uint128 withdrawnAmount1 = uint128(-balanceUpdate.delta1());
```

**File:** src/base/BasePositions.sol (L318-318)
```text
                    // we know cast won't overflow because delta0 and delta1 were originally int128
```

**File:** src/math/delta.sol (L34-69)
```text
function amount0DeltaSorted(uint256 sqrtRatioLower, uint256 sqrtRatioUpper, uint128 liquidity, bool roundUp)
    pure
    returns (uint128 amount0)
{
    unchecked {
        uint256 liquidityX128;
        assembly ("memory-safe") {
            liquidityX128 := shl(128, liquidity)
        }
        if (roundUp) {
            uint256 result0 =
                FixedPointMathLib.fullMulDivUp(liquidityX128, (sqrtRatioUpper - sqrtRatioLower), sqrtRatioUpper);
            assembly ("memory-safe") {
                let result := add(div(result0, sqrtRatioLower), iszero(iszero(mod(result0, sqrtRatioLower))))
                if shr(128, result) {
                    // cast sig "Amount0DeltaOverflow()"
                    mstore(0, 0xb4ef2546)
                    revert(0x1c, 0x04)
                }
                amount0 := result
            }
        } else {
            uint256 result0 =
                FixedPointMathLib.fullMulDivUnchecked(liquidityX128, (sqrtRatioUpper - sqrtRatioLower), sqrtRatioUpper);
            uint256 result = FixedPointMathLib.rawDiv(result0, sqrtRatioLower);
            assembly ("memory-safe") {
                if shr(128, result) {
                    // cast sig "Amount0DeltaOverflow()"
                    mstore(0, 0xb4ef2546)
                    revert(0x1c, 0x04)
                }
                amount0 := result
            }
        }
    }
}
```

**File:** src/math/liquidity.sol (L22-54)
```text
function liquidityDeltaToAmountDelta(
    SqrtRatio sqrtRatio,
    int128 liquidityDelta,
    SqrtRatio sqrtRatioLower,
    SqrtRatio sqrtRatioUpper
) pure returns (int128 delta0, int128 delta1) {
    unchecked {
        if (liquidityDelta == 0) {
            return (0, 0);
        }
        bool isPositive = (liquidityDelta > 0);
        int256 sign = -1 + 2 * int256(LibBit.rawToUint(isPositive));
        // absolute value of a int128 always fits in a uint128
        uint128 magnitude = uint128(FixedPointMathLib.abs(liquidityDelta));

        if (sqrtRatio <= sqrtRatioLower) {
            delta0 = SafeCastLib.toInt128(
                sign * int256(uint256(amount0Delta(sqrtRatioLower, sqrtRatioUpper, magnitude, isPositive)))
            );
        } else if (sqrtRatio < sqrtRatioUpper) {
            delta0 = SafeCastLib.toInt128(
                sign * int256(uint256(amount0Delta(sqrtRatio, sqrtRatioUpper, magnitude, isPositive)))
            );
            delta1 = SafeCastLib.toInt128(
                sign * int256(uint256(amount1Delta(sqrtRatioLower, sqrtRatio, magnitude, isPositive)))
            );
        } else {
            delta1 = SafeCastLib.toInt128(
                sign * int256(uint256(amount1Delta(sqrtRatioLower, sqrtRatioUpper, magnitude, isPositive)))
            );
        }
    }
}
```

**File:** src/Router.sol (L116-116)
```text
                int128 amountCalculated = params.isToken1() ? -balanceUpdate.delta0() : -balanceUpdate.delta1();
```

**File:** src/Core.sol (L811-812)
```text
                int128 calculatedAmountDelta =
                    SafeCastLib.toInt128(FixedPointMathLib.max(type(int128).min, calculatedAmount));
```

**File:** src/extensions/TWAMM.sol (L125-127)
```text
        // checked addition, no overflow of int112 type
        if (FixedPointMathLib.abs(result) > MAX_ABS_VALUE_SALE_RATE_DELTA) {
            revert MaxSaleRateDeltaPerTime();
```

**File:** src/extensions/MEVCapture.sol (L212-213)
```text
            uint256 feeMultiplierX64 =
                (FixedPointMathLib.abs(stateAfter.tick() - tickLast) << 64) / poolKey.config.concentratedTickSpacing();
```
