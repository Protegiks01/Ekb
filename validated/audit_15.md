# Audit Report

## Title
MEVCapture Intra-Block Fee Timing Vulnerability Allows LP Fee Theft

## Summary
The MEVCapture extension contains a critical timing vulnerability where MEV fees generated by swaps in Block N are stored in `savedBalances` but not accumulated to the pool's `feesPerLiquidity` until Block N+1. This one-block delay allows attackers to add liquidity after fees are generated but before accumulation, setting their fee baseline before the increase occurs and thereby stealing fees from legitimate liquidity providers who were active during the swap.

## Impact
**Severity**: High

This vulnerability enables systematic theft of LP fees through timing manipulation. An attacker adding liquidity equal to existing pool liquidity steals approximately 50% of that block's MEV fees; with 9x existing liquidity, they capture ~90% of fees. The attack is repeatable every block with swap activity, requires no special permissions, and can be amplified using flash loans. This directly violates the documented design intent and causes legitimate LPs to systematically lose fee earnings that rightfully belong to them. [1](#0-0) 

## Finding Description

**Location:** `src/extensions/MEVCapture.sol` - `handleForwardData()` function and `accumulatePoolFees()` function

**Intended Logic:** 
The code comment explicitly states the design intent to "Prevent new liquidity from collecting on fees" [1](#0-0) . MEVCapture should ensure positions only earn fees for swaps occurring while they actively provide liquidity, with fees accumulated atomically when generated.

**Actual Logic:**
When `handleForwardData()` processes the first swap in a block, it immediately updates `lastUpdateTime` to the current block timestamp [2](#0-1) , BEFORE the swap generates new MEV fees [3](#0-2) . These new fees are then added to `savedBalances` [4](#0-3)  but NOT accumulated to `feesPerLiquidity`. This creates a one-block delay where fees exist in `savedBalances` but haven't been distributed to existing positions.

**Exploitation Path:**

1. **Block N - First swap generates fees:**
   - User calls swap through MEVCapture
   - `handleForwardData()` checks `if (lastUpdateTime != currentTime)` [5](#0-4)  - TRUE for first swap in block
   - Accumulates old fees from previous block [6](#0-5) 
   - Updates `lastUpdateTime = currentTime` (Block N timestamp) [2](#0-1) 
   - Swap executes and generates NEW MEV fees [3](#0-2) 
   - New fees added to `savedBalances` [4](#0-3) 
   - **Critical state:** `lastUpdateTime = Block N`, new fees in `savedBalances`, NOT in `feesPerLiquidity`

2. **Block N - Attacker adds liquidity in same block:**
   - Attacker calls `Core.updatePosition()` to add liquidity
   - `beforeUpdatePosition` hook invoked [7](#0-6) 
   - MEVCapture's hook calls `accumulatePoolFees()` [8](#0-7) 
   - Check `state.lastUpdateTime() != uint32(block.timestamp)` [9](#0-8)  evaluates FALSE (both equal Block N)
   - Function returns WITHOUT calling `locked_6416899205()`, no fee accumulation occurs
   - `updatePosition()` calculates `feesPerLiquidityInside` [10](#0-9)  using current pool state WITHOUT new MEV fees
   - Attacker's position sets `feesPerLiquidityInsideLast` baseline [11](#0-10)  to this pre-accumulation value

3. **Block N+1 - Fee accumulation:**
   - Any transaction triggers `accumulatePoolFees()`
   - Now `lastUpdateTime (Block N) != block.timestamp (Block N+1)` evaluates TRUE
   - Calls `locked_6416899205()` which loads fees from `savedBalances` [12](#0-11) 
   - `accumulateAsFees()` increases pool's `feesPerLiquidity` [13](#0-12)  by distributing fees across ALL current liquidity
   - Attacker's position now benefits from increased `feesPerLiquidity`

4. **Fee collection:**
   - Position fee calculation uses difference between current and baseline [14](#0-13) 
   - Attacker receives large share of MEV fees generated BEFORE they provided liquidity
   - Legitimate LPs who were active during Block N swap receive diluted fees

**Security Property Broken:**
Violates the documented invariant that positions should only earn fees for periods they actively provide liquidity, as explicitly stated in the code comment [1](#0-0) .

## Impact Explanation

**Affected Assets:** All MEVCapture-enabled pools and their liquidity provider positions.

**Damage Severity:**
- Attacker adding liquidity equal to existing pool liquidity steals ~50% of MEV fees from that block
- Attacker adding 9x existing liquidity captures ~90% of fees  
- Attack is repeatable every block with swap activity
- Legitimate LPs systematically lose significant fee earnings
- High-volume pools with substantial MEV fees suffer greatest impact
- Can be amplified using flash loans with no capital lockup required

**User Impact:** All legitimate liquidity providers in MEVCapture pools receive diluted fee earnings. Victims cannot prevent the attack as it exploits the protocol's core fee accumulation timing mechanism.

**Trigger Conditions:** Any user can execute this attack with capital access (including flash loans) whenever swaps generate MEV fees through tick movement.

## Likelihood Explanation

**Attacker Profile:** Any user with capital access. No special permissions, privileges, or insider knowledge required. MEV searchers and bots will automate this attack.

**Preconditions:**
1. Pool uses MEVCapture extension (intended for all MEV-capturing pools)
2. Swaps generate MEV fees through tick movement (common in volatile markets)
3. Pool has sufficient liquidity to make attack profitable

**Execution Complexity:** Simple single-block attack pattern:
- Monitor mempool or blocks for large swaps through MEVCapture
- Submit transaction adding liquidity in same block after swap
- Collect fees in next block
- Remove liquidity and repeat

**Economic Cost:** Only gas fees for position management. No capital lockup required with flash loans.

**Frequency:** Exploitable every block with swap activity. Scalable across all MEVCapture pools simultaneously.

**Overall Likelihood:** HIGH - Trivially automatable, economically rational, repeatable attack with clear profit mechanism and no barriers to entry.

## Recommendation

**Primary Fix:**
The root cause is updating `lastUpdateTime` BEFORE new fees are generated. Modify `handleForwardData()` to accumulate fees IMMEDIATELY after generating them in the same transaction, before updating `savedBalances`. This ensures fees are distributed atomically to the exact set of LPs who were active during the swap, eliminating the timing window.

**Implementation approach:**
After calculating new MEV fees (line 252), immediately call `CORE.accumulateAsFees()` with those fees before saving to `savedBalances`. This makes the fee distribution synchronous with fee generation, preventing any position added in the same block from claiming those fees.

**Alternative Mitigation:**
Track the block number when fees were generated in `savedBalances` and prevent positions created in that same block from claiming those specific fees during accumulation. However, this adds complexity compared to immediate accumulation.

## Notes

This vulnerability is particularly severe because:
1. It's invisible to victims - LPs see reduced earnings with no indication of theft
2. It's economically rational - profitable for attackers to exploit continuously  
3. It's automatable - MEV bots can execute this systematically across all pools
4. It violates the stated design intent per code comments
5. Flash loans eliminate capital requirements, making it accessible to any attacker

This is NOT standard concentrated liquidity behavior. In Uniswap v3 and similar protocols, fees are accumulated immediately when generated, preventing this timing attack vector. The MEVCapture design introduced a one-block accumulation delay that creates this exploitation window.

The existing test suite has a coverage gap - `test_new_position_does_not_get_fees()` only validates positions created in the NEXT block after swaps, not positions created in the SAME block, which is why this vulnerability was not detected during testing.

### Citations

**File:** src/extensions/MEVCapture.sol (L96-96)
```text
    /// Prevents new liquidity from collecting on fees
```

**File:** src/extensions/MEVCapture.sol (L97-102)
```text
    function beforeUpdatePosition(Locker, PoolKey memory poolKey, PositionId, int128)
        external
        override(BaseExtension, IExtension)
    {
        accumulatePoolFees(poolKey);
    }
```

**File:** src/extensions/MEVCapture.sol (L110-110)
```text
        if (state.lastUpdateTime() != uint32(block.timestamp)) {
```

**File:** src/extensions/MEVCapture.sol (L136-148)
```text
        (int32 tick, uint128 fees0, uint128 fees1) = loadCoreState(poolId, poolKey.token0, poolKey.token1);

        if (fees0 != 0 || fees1 != 0) {
            CORE.accumulateAsFees(poolKey, fees0, fees1);
            unchecked {
                CORE.updateSavedBalances(
                    poolKey.token0,
                    poolKey.token1,
                    PoolId.unwrap(poolId),
                    -int256(uint256(fees0)),
                    -int256(uint256(fees1))
                );
            }
```

**File:** src/extensions/MEVCapture.sol (L191-191)
```text
            if (lastUpdateTime != currentTime) {
```

**File:** src/extensions/MEVCapture.sol (L195-199)
```text
                if (fees0 != 0 || fees1 != 0) {
                    CORE.accumulateAsFees(poolKey, fees0, fees1);
                    // never overflows int256 container
                    saveDelta0 -= int256(uint256(fees0));
                    saveDelta1 -= int256(uint256(fees1));
```

**File:** src/extensions/MEVCapture.sol (L203-206)
```text
                setPoolState({
                    poolId: poolId,
                    state: createMEVCapturePoolState({_lastUpdateTime: currentTime, _tickLast: tickLast})
                });
```

**File:** src/extensions/MEVCapture.sol (L212-252)
```text
            uint256 feeMultiplierX64 =
                (FixedPointMathLib.abs(stateAfter.tick() - tickLast) << 64) / poolKey.config.concentratedTickSpacing();
            uint64 poolFee = poolKey.config.fee();
            uint64 additionalFee = uint64(FixedPointMathLib.min(type(uint64).max, (feeMultiplierX64 * poolFee) >> 64));

            if (additionalFee != 0) {
                if (params.isExactOut()) {
                    // take an additional fee from the calculated input amount equal to the `additionalFee - poolFee`
                    if (balanceUpdate.delta0() > 0) {
                        uint128 inputAmount = uint128(uint256(int256(balanceUpdate.delta0())));
                        // first remove the fee to get the original input amount before we compute the additional fee
                        inputAmount -= computeFee(inputAmount, poolFee);
                        int128 fee = SafeCastLib.toInt128(amountBeforeFee(inputAmount, additionalFee) - inputAmount);

                        saveDelta0 += fee;
                        balanceUpdate = createPoolBalanceUpdate(balanceUpdate.delta0() + fee, balanceUpdate.delta1());
                    } else if (balanceUpdate.delta1() > 0) {
                        uint128 inputAmount = uint128(uint256(int256(balanceUpdate.delta1())));
                        // first remove the fee to get the original input amount before we compute the additional fee
                        inputAmount -= computeFee(inputAmount, poolFee);
                        int128 fee = SafeCastLib.toInt128(amountBeforeFee(inputAmount, additionalFee) - inputAmount);

                        saveDelta1 += fee;
                        balanceUpdate = createPoolBalanceUpdate(balanceUpdate.delta0(), balanceUpdate.delta1() + fee);
                    }
                } else {
                    if (balanceUpdate.delta0() < 0) {
                        uint128 outputAmount = uint128(uint256(-int256(balanceUpdate.delta0())));
                        int128 fee = SafeCastLib.toInt128(computeFee(outputAmount, additionalFee));

                        saveDelta0 += fee;
                        balanceUpdate = createPoolBalanceUpdate(balanceUpdate.delta0() + fee, balanceUpdate.delta1());
                    } else if (balanceUpdate.delta1() < 0) {
                        uint128 outputAmount = uint128(uint256(-int256(balanceUpdate.delta1())));
                        int128 fee = SafeCastLib.toInt128(computeFee(outputAmount, additionalFee));

                        saveDelta1 += fee;
                        balanceUpdate = createPoolBalanceUpdate(balanceUpdate.delta0(), balanceUpdate.delta1() + fee);
                    }
                }
            }
```

**File:** src/extensions/MEVCapture.sol (L254-256)
```text
            if (saveDelta0 != 0 || saveDelta1 != 0) {
                CORE.updateSavedBalances(poolKey.token0, poolKey.token1, PoolId.unwrap(poolId), saveDelta0, saveDelta1);
            }
```

**File:** src/Core.sol (L254-267)
```text
                if (liquidity != 0) {
                    StorageSlot slot0 = CoreStorageLayout.poolFeesPerLiquiditySlot(poolId);

                    if (amount0 != 0) {
                        slot0.store(
                            bytes32(uint256(slot0.load()) + FixedPointMathLib.rawDiv(amount0 << 128, liquidity))
                        );
                    }
                    if (amount1 != 0) {
                        StorageSlot slot1 = slot0.next();
                        slot1.store(
                            bytes32(uint256(slot1.load()) + FixedPointMathLib.rawDiv(amount1 << 128, liquidity))
                        );
                    }
```

**File:** src/Core.sol (L367-368)
```text
        IExtension(poolKey.config.extension())
            .maybeCallBeforeUpdatePosition(locker, poolKey, positionId, liquidityDelta);
```

**File:** src/Core.sol (L403-407)
```text
                if (liquidityNext != 0) {
                    feesPerLiquidityInside = _getPoolFeesPerLiquidityInside(
                        poolId, state.tick(), positionId.tickLower(), positionId.tickUpper()
                    );
                }
```

**File:** src/Core.sol (L436-437)
```text
                position.feesPerLiquidityInsideLast =
                    feesPerLiquidityInside.sub(feesPerLiquidityFromAmounts(fees0, fees1, liquidityNext));
```

**File:** src/types/position.sol (L33-51)
```text
function fees(Position memory position, FeesPerLiquidity memory feesPerLiquidityInside)
    pure
    returns (uint128, uint128)
{
    uint128 liquidity;
    uint256 difference0;
    uint256 difference1;
    assembly ("memory-safe") {
        liquidity := mload(add(position, 0x20))
        // feesPerLiquidityInsideLast is now at offset 0x40 due to extraData field
        let positionFpl := mload(add(position, 0x40))
        difference0 := sub(mload(feesPerLiquidityInside), mload(positionFpl))
        difference1 := sub(mload(add(feesPerLiquidityInside, 0x20)), mload(add(positionFpl, 0x20)))
    }

    return (
        uint128(FixedPointMathLib.fullMulDivN(difference0, liquidity, 128)),
        uint128(FixedPointMathLib.fullMulDivN(difference1, liquidity, 128))
    );
```
