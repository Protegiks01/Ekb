## Title
MEVCapture Fee Theft via Intra-Block Time Desynchronization Allowing Liquidity Manipulation

## Summary
The `locked_6416899205()` function in MEVCapture updates `lastUpdateTime` even when fees are zero, creating a one-block delay between fee generation and fee accumulation. Attackers can exploit this by adding liquidity after fees are generated but before they're accumulated, stealing fee share from legitimate LPs who provided liquidity during the actual swap.

## Impact
**Severity**: High

## Finding Description
**Location:** `src/extensions/MEVCapture.sol` - `locked_6416899205()` function (lines 127-155) and `handleForwardData()` (lines 177-260)

**Intended Logic:** MEVCapture is designed to charge additional fees based on tick movement during swaps and distribute these fees proportionally to liquidity providers who were active during the swap.

**Actual Logic:** When `locked_6416899205()` updates `lastUpdateTime` (line 151-154) regardless of whether fees were zero, it prevents further fee accumulation in the same block. [1](#0-0)  This creates a critical timing vulnerability where:

1. MEV fees generated by swaps are added to `savedBalances` but not immediately accumulated to the pool
2. `lastUpdateTime` is updated, blocking further accumulation in that block
3. New positions added in the same block get their `feesPerLiquidityInsideLast` snapshot set BEFORE fees are accumulated
4. When fees accumulate in the next block, the new positions receive a share despite not providing liquidity during the swap

**Exploitation Path:**

1. **Block N, T1**: Attacker or any user performs swap through `MEVCapture.forward()` that moves ticks significantly
   - `handleForwardData()` checks `lastUpdateTime != currentTime` (line 191), condition is TRUE for first swap [2](#0-1) 
   - Old fees accumulated, `lastUpdateTime` updated to Block N timestamp (line 203-206)
   - Swap executes, generates new MEV fees based on tick movement (lines 212-252)
   - New fees added to `savedBalances` via `updateSavedBalances()` (line 255) [3](#0-2) 
   - These fees NOT yet accumulated to pool's `feesPerLiquidity`

2. **Block N, T2**: Attacker calls `Core.updatePosition()` to add massive liquidity
   - `beforeUpdatePosition` hook calls `accumulatePoolFees()` [4](#0-3) 
   - Check `lastUpdateTime != block.timestamp` is FALSE (both equal Block N) [5](#0-4) 
   - Function returns without accumulating fees from T1
   - `updatePosition()` calculates current `feesPerLiquidityInside` which does NOT include MEV fees yet [6](#0-5) 
   - Attacker's position sets `feesPerLiquidityInsideLast` to this pre-accumulation value [7](#0-6) 

3. **Block N+1, T1**: Any transaction triggers fee accumulation
   - `lastUpdateTime (Block N) != block.timestamp (Block N+1)` is TRUE
   - `locked_6416899205()` loads fees from savedBalances, calls `accumulateAsFees()` [8](#0-7) 
   - `accumulateAsFees()` increases `feesPerLiquidity` by distributing fees across ALL current liquidity [9](#0-8) 
   - Attacker's position now earns: `(new FPL - old FPL) * attacker_liquidity`

4. **Block N+1, T2**: Attacker collects fees
   - Position fee calculation: `fees = (feesPerLiquidityInside - feesPerLiquidityInsideLast) * liquidity` [10](#0-9) 
   - Attacker receives large share of MEV fees that were generated BEFORE they added liquidity
   - Legitimate LPs who were active during the swap in Block N are diluted

**Security Property Broken:** Violates **Fee Accounting** invariant - "Position fee collection must be accurate and never allow double-claiming". Attacker claims fees they didn't earn, effectively stealing from legitimate LPs.

## Impact Explanation
- **Affected Assets**: All MEVCapture-enabled pools. LP fee earnings are stolen by attackers who manipulate position timing.
- **Damage Severity**: Attacker can steal a proportional share of MEV fees based on liquidity added. If attacker adds liquidity equal to existing pool liquidity, they steal ~50% of MEV fees from that block. With 9x existing liquidity, they steal ~90% of fees. Loss compounds over time as attackers repeatedly exploit each block's MEV fee generation.
- **User Impact**: All legitimate LPs in MEVCapture pools suffer diluted fee earnings. Especially harmful in high-volume pools where MEV fees are substantial. Victims cannot prevent the attack as it exploits timing of fee accumulation.

## Likelihood Explanation
- **Attacker Profile**: Any user with capital can exploit this. No special privileges required. Sophisticated searchers/MEV bots will automate this attack.
- **Preconditions**: 
  - Pool must use MEVCapture extension (all pools meant to capture MEV)
  - Sufficient liquidity available to make attack profitable
  - Swaps must generate MEV fees (common in volatile markets)
- **Execution Complexity**: Simple single-block attack. Attacker can bundle transactions or use flashloans to amplify impact without permanent capital commitment.
- **Frequency**: Exploitable on EVERY block with swap activity. Attacker can:
  - Monitor mempool for large swaps generating MEV fees
  - Frontrun with liquidity addition immediately after swap
  - Collect fees in next block
  - Remove liquidity and repeat

## Recommendation

```solidity
// In src/extensions/MEVCapture.sol, function locked_6416899205, lines 138-154:

// CURRENT (vulnerable):
// if (fees0 != 0 || fees1 != 0) {
//     CORE.accumulateAsFees(poolKey, fees0, fees1);
//     unchecked {
//         CORE.updateSavedBalances(..., -int256(uint256(fees0)), -int256(uint256(fees1)));
//     }
// }
// setPoolState({poolId: poolId, state: createMEVCapturePoolState({_lastUpdateTime: uint32(block.timestamp), _tickLast: tick})});

// FIXED:
if (fees0 != 0 || fees1 != 0) {
    CORE.accumulateAsFees(poolKey, fees0, fees1);
    unchecked {
        CORE.updateSavedBalances(
            poolKey.token0,
            poolKey.token1,
            PoolId.unwrap(poolId),
            -int256(uint256(fees0)),
            -int256(uint256(fees1))
        );
    }
    // Only update lastUpdateTime when fees are actually accumulated
    setPoolState({
        poolId: poolId,
        state: createMEVCapturePoolState({_lastUpdateTime: uint32(block.timestamp), _tickLast: tick})
    });
} else {
    // When no fees to accumulate, update only tickLast, preserve lastUpdateTime
    MEVCapturePoolState oldState = getPoolState(poolId);
    setPoolState({
        poolId: poolId,
        state: createMEVCapturePoolState({_lastUpdateTime: oldState.lastUpdateTime(), _tickLast: tick})
    });
}
```

**Alternative Mitigation:** Modify `handleForwardData()` to accumulate fees IMMEDIATELY after generating them in the same transaction, before updating `lastUpdateTime`. This ensures fees are distributed only to LPs who were active during the swap.

## Proof of Concept

```solidity
// File: test/Exploit_MEVCaptureTimingTheft.t.sol
// Run with: forge test --match-test test_StealFeesViaTimingManipulation -vvv

pragma solidity ^0.8.31;

import "forge-std/Test.sol";
import "../src/Core.sol";
import "../src/Positions.sol";
import "../src/extensions/MEVCapture.sol";

contract Exploit_MEVCaptureTimingTheft is Test {
    Core core;
    Positions positions;
    MEVCapture mevCapture;
    address attacker;
    address legitimateLP;
    
    function setUp() public {
        // Deploy contracts
        core = new Core();
        mevCapture = new MEVCapture(core);
        positions = new Positions(core, address(this));
        
        attacker = makeAddr("attacker");
        legitimateLP = makeAddr("legitimateLP");
        
        // Fund accounts
        deal(legitimateLP, 1000 ether);
        deal(attacker, 1000 ether);
    }
    
    function test_StealFeesViaTimingManipulation() public {
        // SETUP: Legitimate LP provides initial liquidity
        vm.startPrank(legitimateLP);
        // Create position with 100 ETH liquidity
        positions.mint(/* pool params, 100 ETH */);
        vm.stopPrank();
        
        // Record legitimate LP's initial fee balance
        uint256 lpFeesBeforeAttack = positions.getPositionFees(/* LP position ID */);
        
        // BLOCK N - EXPLOIT PHASE 1: Large swap generates MEV fees
        vm.roll(block.number + 1);
        // Swap that moves price significantly, generating 10 ETH in MEV fees
        core.lock(/* swap through MEVCapture.forward() */);
        // At this point: fees in savedBalances, lastUpdateTime updated, fees NOT accumulated
        
        // BLOCK N - EXPLOIT PHASE 2: Attacker adds 900 ETH liquidity in same block
        vm.startPrank(attacker);
        // beforeUpdatePosition calls accumulatePoolFees() but lastUpdateTime check fails
        // Attacker's feesPerLiquidityInsideLast set BEFORE fee accumulation
        positions.mint(/* pool params, 900 ETH liquidity */);
        vm.stopPrank();
        
        // BLOCK N+1 - Trigger fee accumulation
        vm.roll(block.number + 1);
        core.lock(/* any action triggering accumulatePoolFees */);
        // Now fees distributed: attacker gets 90% (900/(100+900)), LP gets 10%
        
        // VERIFY: Attacker stole fees
        uint256 attackerFees = positions.getPositionFees(/* attacker position ID */);
        uint256 lpFeesAfter = positions.getPositionFees(/* LP position ID */);
        
        assertGt(attackerFees, 9 ether, "Attacker should receive ~90% of 10 ETH = 9 ETH");
        assertLt(lpFeesAfter - lpFeesBeforeAttack, 1 ether, "LP should only receive ~10% = 1 ETH");
        assertEq(attackerFees + (lpFeesAfter - lpFeesBeforeAttack), 10 ether, "Total fees = 10 ETH");
        
        // Attacker earned 9 ETH of fees despite not providing liquidity during the swap
        // This is stolen from the legitimate LP who had 100% liquidity during swap
    }
}
```

## Notes

The vulnerability fundamentally stems from the design decision to update `lastUpdateTime` unconditionally in `locked_6416899205()`. This creates a temporal mismatch where:
- Fee generation timestamp â‰  Fee accumulation timestamp
- Position creation can occur between these events
- New positions incorrectly receive fees from pre-existing swaps

The fix must ensure atomicity: fees generated in a swap must be immediately accumulated to the exact set of LPs who were active during that swap, with no opportunity for position manipulation in between.

### Citations

**File:** src/extensions/MEVCapture.sol (L97-102)
```text
    function beforeUpdatePosition(Locker, PoolKey memory poolKey, PositionId, int128)
        external
        override(BaseExtension, IExtension)
    {
        accumulatePoolFees(poolKey);
    }
```

**File:** src/extensions/MEVCapture.sol (L110-125)
```text
        if (state.lastUpdateTime() != uint32(block.timestamp)) {
            address target = address(CORE);
            assembly ("memory-safe") {
                let o := mload(0x40)
                mstore(o, shl(224, 0xf83d08ba))
                mcopy(add(o, 4), poolKey, 96)
                mstore(add(o, 100), poolId)

                // If the call failed, pass through the revert
                if iszero(call(gas(), target, 0, o, 132, 0, 0)) {
                    returndatacopy(o, 0, returndatasize())
                    revert(o, returndatasize())
                }
            }
        }
    }
```

**File:** src/extensions/MEVCapture.sol (L136-154)
```text
        (int32 tick, uint128 fees0, uint128 fees1) = loadCoreState(poolId, poolKey.token0, poolKey.token1);

        if (fees0 != 0 || fees1 != 0) {
            CORE.accumulateAsFees(poolKey, fees0, fees1);
            unchecked {
                CORE.updateSavedBalances(
                    poolKey.token0,
                    poolKey.token1,
                    PoolId.unwrap(poolId),
                    -int256(uint256(fees0)),
                    -int256(uint256(fees1))
                );
            }
        }

        setPoolState({
            poolId: poolId,
            state: createMEVCapturePoolState({_lastUpdateTime: uint32(block.timestamp), _tickLast: tick})
        });
```

**File:** src/extensions/MEVCapture.sol (L191-207)
```text
            if (lastUpdateTime != currentTime) {
                (int32 tick, uint128 fees0, uint128 fees1) =
                    loadCoreState({poolId: poolId, token0: poolKey.token0, token1: poolKey.token1});

                if (fees0 != 0 || fees1 != 0) {
                    CORE.accumulateAsFees(poolKey, fees0, fees1);
                    // never overflows int256 container
                    saveDelta0 -= int256(uint256(fees0));
                    saveDelta1 -= int256(uint256(fees1));
                }

                tickLast = tick;
                setPoolState({
                    poolId: poolId,
                    state: createMEVCapturePoolState({_lastUpdateTime: currentTime, _tickLast: tickLast})
                });
            }
```

**File:** src/extensions/MEVCapture.sol (L254-256)
```text
            if (saveDelta0 != 0 || saveDelta1 != 0) {
                CORE.updateSavedBalances(poolKey.token0, poolKey.token1, PoolId.unwrap(poolId), saveDelta0, saveDelta1);
            }
```

**File:** src/Core.sol (L254-267)
```text
                if (liquidity != 0) {
                    StorageSlot slot0 = CoreStorageLayout.poolFeesPerLiquiditySlot(poolId);

                    if (amount0 != 0) {
                        slot0.store(
                            bytes32(uint256(slot0.load()) + FixedPointMathLib.rawDiv(amount0 << 128, liquidity))
                        );
                    }
                    if (amount1 != 0) {
                        StorageSlot slot1 = slot0.next();
                        slot1.store(
                            bytes32(uint256(slot1.load()) + FixedPointMathLib.rawDiv(amount1 << 128, liquidity))
                        );
                    }
```

**File:** src/Core.sol (L403-407)
```text
                if (liquidityNext != 0) {
                    feesPerLiquidityInside = _getPoolFeesPerLiquidityInside(
                        poolId, state.tick(), positionId.tickLower(), positionId.tickUpper()
                    );
                }
```

**File:** src/Core.sol (L436-437)
```text
                position.feesPerLiquidityInsideLast =
                    feesPerLiquidityInside.sub(feesPerLiquidityFromAmounts(fees0, fees1, liquidityNext));
```

**File:** src/types/position.sol (L33-51)
```text
function fees(Position memory position, FeesPerLiquidity memory feesPerLiquidityInside)
    pure
    returns (uint128, uint128)
{
    uint128 liquidity;
    uint256 difference0;
    uint256 difference1;
    assembly ("memory-safe") {
        liquidity := mload(add(position, 0x20))
        // feesPerLiquidityInsideLast is now at offset 0x40 due to extraData field
        let positionFpl := mload(add(position, 0x40))
        difference0 := sub(mload(feesPerLiquidityInside), mload(positionFpl))
        difference1 := sub(mload(add(feesPerLiquidityInside, 0x20)), mload(add(positionFpl, 0x20)))
    }

    return (
        uint128(FixedPointMathLib.fullMulDivN(difference0, liquidity, 128)),
        uint128(FixedPointMathLib.fullMulDivN(difference1, liquidity, 128))
    );
```
